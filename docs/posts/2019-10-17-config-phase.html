<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>greghale.io - Organizing configs by usage phase</title>
        <link rel="stylesheet" href="../css/default.css" />
	<link rel="stylesheet" href="../css/syntax.css" />
        <link href="../css/NanumGothic-Bold.ttf" rel="stylesheet">
    </head>
    <body>
      <div class="content">
        <header>
            <div class="logo">
                <a href="../">blog.greghale.io</a>
            </div>
            <nav>
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </nav>
        </header>

        <main role="main">
            <!-- <h1>Organizing configs by usage phase</h1> -->
            <article>
    <section class="header">
        Posted on October 17, 2019
        
    </section>
    <section>
        <h1>
Organizing configs by usage phase
</h1>

<h2>
Configuration sprawl
</h2>
<p>Have you found your configuration handling begins to sprawl as you add more configuration to your program? This example makes two database connections and allows the hostname and logging level to be configured. Imagine how <code>main</code> might grow over time as different people follow the patterns they find here while adding more parameters.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ConfigExample1</span> <span class="fu">=</span> <span class="dt">ConfigExample1</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2">  {<span class="ot"> hostname   ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3">  ,<span class="ot"> userDBUser ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4">  ,<span class="ot"> userDBPass ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  ,<span class="ot"> userDBDB   ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  ,<span class="ot"> userDBPort ::</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  ,<span class="ot"> userDBHost ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8">  ,<span class="ot"> logLevel ::</span> <span class="dt">Katip.Severity</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  ,<span class="ot"> analysisDBUser ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  ,<span class="ot"> analysisDBHost ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  ,<span class="ot"> analysisDBPort ::</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  ,<span class="ot"> analysisDBDB   ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  ,<span class="ot"> analysisDBPass ::</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  } <span class="kw">deriving</span> (<span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-18" data-line-number="18">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  <span class="dt">ConfigExample1</span>{<span class="fu">..</span>} <span class="ot">&lt;-</span> loadConfig <span class="st">&quot;local.yaml&quot;</span></a>
<a class="sourceLine" id="cb1-20" data-line-number="20">  print <span class="st">&quot;Connecting to User Database&quot;</span></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">  userDB <span class="ot">&lt;-</span> PG.connect <span class="dt">PG.ConnectInfo</span></a>
<a class="sourceLine" id="cb1-22" data-line-number="22">      { PG.connectUser     <span class="fu">=</span> userDBUser</a>
<a class="sourceLine" id="cb1-23" data-line-number="23">      , PG.connectHost     <span class="fu">=</span> userDBHost</a>
<a class="sourceLine" id="cb1-24" data-line-number="24">      , PG.connectPort     <span class="fu">=</span> fromIntegral userDBPort</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">      , PG.connectPassword <span class="fu">=</span> userDBPass</a>
<a class="sourceLine" id="cb1-26" data-line-number="26">      , PG.connectDatabase <span class="fu">=</span> userDBDB</a>
<a class="sourceLine" id="cb1-27" data-line-number="27">      }</a>
<a class="sourceLine" id="cb1-28" data-line-number="28">  <span class="co">-- ... a block of initialization code</span></a>
<a class="sourceLine" id="cb1-29" data-line-number="29">  <span class="co">-- ... maybe written by other team members</span></a>
<a class="sourceLine" id="cb1-30" data-line-number="30">  <span class="co">--</span></a>
<a class="sourceLine" id="cb1-31" data-line-number="31">  analysisDB <span class="ot">&lt;-</span> PG.connect <span class="dt">PG.ConnectInfo</span></a>
<a class="sourceLine" id="cb1-32" data-line-number="32">      { PG.connectUser     <span class="fu">=</span> analysisDBUser</a>
<a class="sourceLine" id="cb1-33" data-line-number="33">      , PG.connectHost     <span class="fu">=</span> analysisDBHost</a>
<a class="sourceLine" id="cb1-34" data-line-number="34">      , PG.connectPort     <span class="fu">=</span> fromIntegral analysisDBPort</a>
<a class="sourceLine" id="cb1-35" data-line-number="35">      , PG.connectPassword <span class="fu">=</span> analysisDBPass</a>
<a class="sourceLine" id="cb1-36" data-line-number="36">      , PG.connectDatabase <span class="fu">=</span> analysisDBDB</a>
<a class="sourceLine" id="cb1-37" data-line-number="37">      }  </a>
<a class="sourceLine" id="cb1-38" data-line-number="38">  runBusinessLogic analysisDB userDB logLevel (Text.unpack hostname)</a>
<a class="sourceLine" id="cb1-39" data-line-number="39"></a>
<a class="sourceLine" id="cb1-40" data-line-number="40"></a>
<a class="sourceLine" id="cb1-41" data-line-number="41"></a>
<a class="sourceLine" id="cb1-42" data-line-number="42">runBusinessLogic</a>
<a class="sourceLine" id="cb1-43" data-line-number="43"><span class="ot">  ::</span> <span class="dt">PG.Connection</span></a>
<a class="sourceLine" id="cb1-44" data-line-number="44">  <span class="ot">-&gt;</span> <span class="dt">PG.Connection</span></a>
<a class="sourceLine" id="cb1-45" data-line-number="45">  <span class="ot">-&gt;</span> <span class="dt">Katip.Severity</span></a>
<a class="sourceLine" id="cb1-46" data-line-number="46">  <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb1-47" data-line-number="47">  <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-48" data-line-number="48">runBusinessLogic userDB analysisDB logLevel myHostname <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-49" data-line-number="49">  undefined</a></code></pre></div>
<p>What problems will we run into as we try to scale this program up?</p>
<ul>
<li><em>Flat format</em> Without organization, it’s easy for config files and their parsers to become confusing</li>
<li><em>Unchecked Redundancy</em> The fields of <code>ConfigExample1</code> correspond to the arguments of <code>runBusinessLogic</code>, but the correspondence is loose (we have a collection of <code>Text</code> and <code>Int</code> fields in the config but a <code>PG.Connection</code> in the arguments.</li>
<li><em>Ad-hoc resource acquisition</em> The code used for reading config fields and creating resources from them can get messy quickly</li>
</ul>
<h2>
Organizing configuration
</h2>
<p>We can address these problems and add a lot of structure to our configuration. Let’s start by drawing a connection between the configuration phase, and the running phase. We’ll start by using a single configuration type that abstracts over the <em>phase</em> at which it is used:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ConfigF</span> (<span class="ot">p ::</span> <span class="dt">Phase</span>) <span class="fu">=</span> <span class="dt">Config</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  {<span class="ot"> userDB     ::</span> <span class="dt">AtPhase</span> p <span class="dt">PG.Connection</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  ,<span class="ot"> analysisDB ::</span> <span class="dt">AtPhase</span> p <span class="dt">PG.Connection</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  ,<span class="ot"> hostname   ::</span> <span class="dt">Text</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  ,<span class="ot"> logLevel   ::</span> <span class="dt">Katip.Severity</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  } <span class="kw">deriving</span> (<span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb2-7" data-line-number="7"></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"><span class="kw">type</span> <span class="dt">Config</span>    <span class="fu">=</span> <span class="dt">ConfigF</span> '<span class="dt">ConfigTime</span></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="kw">type</span> <span class="dt">Resources</span> <span class="fu">=</span> <span class="dt">ConfigF</span> '<span class="dt">RunTime</span></a></code></pre></div>
<p>Some of our configuration fields are regular Haskell datatypes, like <code>Text</code> and <code>Katip.Severity</code>. These values are specified and used in the same way. But the <code>userDB</code> and <code>analysisDB</code> fields are defined in terms of <code>Phase</code> and <code>AtPhase</code>, which we are about to define.</p>
<p>Accepting some complexity here allows us to share a single type definition for specifying two things (a) the configuration <em>data</em> and (b) the configuration <em>result</em>, in one go.</p>
<p>Our <code>main</code> function will look more like this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">main' <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="ot">  cfg ::</span> <span class="dt">Config</span>    <span class="ot">&lt;-</span> loadConfig <span class="st">&quot;local.yaml&quot;</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">  res ::</span> <span class="dt">Resources</span> <span class="ot">&lt;-</span> buildConfig cfg</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  runBusinessLogic' res</a>
<a class="sourceLine" id="cb3-5" data-line-number="5"></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="ot">runBusinessLogic' ::</span> <span class="dt">Resources</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">runBusinessLogic' <span class="fu">=</span> undefined</a></code></pre></div>
<p>Whether the added complexity is worth it depends on a few things.</p>
<ul>
<li>
<em>Configuration complexity</em> If your configuration is simple, then you don’t benefit from deduplicating the configuration and runtime types
</li>
<li>
<em>Complexity budget</em> We’ll be adding a typeclass and a type family. If there are other aspects of your codebase that use your complexity budget, or if the budget is low for other reasons, then it’s best to treat this technique as a fun curiosity. Use your budget on something with a higher power-to-weight ratio, like <a href="https://dhall-lang.org">dhall</a>
</li>
</ul>
<p>Let’s build the required machinery.</p>
<p>First, we use <code>DataKinds</code> to define a new kind <code>Phase</code> inhabited by two types <code>’ConfigTime</code> and <code>’RunTime</code> to specialize our application’s configuration for one phase or the other.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Phase</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">ConfigTime</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">RunTime</span></a></code></pre></div>
<p>Next, a type family will let us associate a configuration type to a runtime type for some particular resource.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">class</span> <span class="dt">HasPhases</span> t <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="kw">type</span> <span class="dt">AtPhase</span> (<span class="ot">p ::</span> <span class="dt">Phase</span>) t</a>
<a class="sourceLine" id="cb5-3" data-line-number="3"></a>
<a class="sourceLine" id="cb5-4" data-line-number="4"><span class="kw">instance</span> <span class="dt">HasPhases</span> <span class="dt">PG.Connection</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="kw">type</span> <span class="dt">AtPhase</span> '<span class="dt">ConfigTime</span> <span class="dt">PG.Connection</span> <span class="fu">=</span> <span class="dt">PG.ConnectInfo</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  <span class="kw">type</span> <span class="dt">AtPhase</span> '<span class="dt">RunTime</span>    <span class="dt">PG.Connection</span> <span class="fu">=</span> <span class="dt">PG.Connection</span></a></code></pre></div>
<p>Another typeclass allows the construction of a resource from its configuration data. The two type parameters correspond to the configtime and runtime types.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">class</span> <span class="dt">ToRuntime</span> cty rty <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">  toRuntime ::</span> cty <span class="ot">-&gt;</span> <span class="dt">IO</span> rty</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"></a>
<a class="sourceLine" id="cb6-4" data-line-number="4"><span class="co">-- | Catch-all instance for regular (not phase-specific) types</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">ToRuntime</span> ty ty <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">  toRuntime <span class="fu">=</span> return</a>
<a class="sourceLine" id="cb6-7" data-line-number="7"></a>
<a class="sourceLine" id="cb6-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">ToRuntime</span> <span class="dt">PG.ConnectInfo</span> <span class="dt">PG.Connection</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  toRuntime <span class="fu">=</span> PG.connect</a></code></pre></div>
<p>There is a catch-all instance for cases when the configtime type is the same as the runtime type. When we eventually process our configuration record, the catch-all instance will apply to any field with a regular type, like our <code>hostname</code> field. (It would also match any <code>AtPhase</code> fields where configtime type is equal to the runtime type.. but if we ever use <code>AtPhase</code>, we would do that <em>in order to</em> let the types differ across phases, so we won’t encounter this case. Sorry for the aside, I hope it makes sense)</p>
<h2>
generic-lens
</h2>
<p>In order to have our <code>buildConfig</code> function, we will use some fabulous magic from <a href="http://hackage.haskell.org/package/generic-lens">generic-lens</a>. Specifically, <a href="http://hackage.haskell.org/package/generic-lens-1.2.0.1/docs/Data-Generics-Product-Constraints.html#v:constraints"><code>constraints</code></a> allows us to traverse a record, applying an effectful function at every field with a type satisfying some particular constraint.</p>
<p>We choose that constraint to be our <code>ToRuntime</code> class.</p>
<p>Now we can write <code>buildConfig</code> without repeating any details about the internals of our configuration record.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="ot">buildConfig ::</span> <span class="dt">ConfigF</span> <span class="dt">ConfigTime</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">ConfigF</span> <span class="dt">RunTime</span>)</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">buildConfig <span class="fu">=</span> GenericLens.constraints <span class="fu">@</span><span class="dt">ToRuntime</span> toRuntime</a></code></pre></div>
<h2>
Summing up
</h2>
<p>Summing up, we have removed a few types of duplication and informality from the process of building runtime resources from configuration data.</p>
<p>We parameterized a single configuration record by the phase, either configuration time or runtime.</p>
<p>And we concentrated the work of instantiating a runtime resource record from the configuration record into a very generic function.</p>
<p>Was it worth it? In effect, we sacrificed <code>Haskell98</code>’s simplicity at the altar of the DRY (Don’t Repeat Yourself) principle. Repetition is legitimately dangerous, especially in a codebase with multiple authors, written in a language where type safety encourages us to skimp on testing. The competing interests here (redundancy vs. complexity) depend on just how much redundancy you are cleaning up.</p>
<p>Thanks to Sarah Brofeldt (<a href="https://github.com/srhb">@srhb</a>), who fleshed out the idea with me and did much of the implementation. Simple as it may look, we had to explore quite a few paths before we found this solution.</p>
<p>Thanks also to K.A. Buhr for his very helpful <a href="https://stackoverflow.com/questions/51388962/how-to-derive-generic-traversals-that-involve-a-type-family/51409436#51409436">answer</a> on StackOverflow. <a href="https://github.com/rossabaker">Ross Baker</a> read a draft of this post and gave great suggestions for improvement - Thanks!</p>
<h2>
Related work
</h2>
<ul>
<li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/11/trees-that-grow.pdf">Trees that Grow</a></li>
<li><a href="https://reasonablypolymorphic.com/blog/higher-kinded-data/">Higher-Kinded Data</a></li>
</ul>
    </section>
</article>

        </main>

        <footer>
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </footer>
	</content>
    </body>
</html>
